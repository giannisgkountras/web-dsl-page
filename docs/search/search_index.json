{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>WebDSL is an external Domain-Specific Language (DSL) designed for generating full-stack applications. It integrates multiple data sources, including databases, message brokers, and REST APIs, while also supporting static components. At its core, WebDSL revolves around entities, which are linked to data sources, define the data model, and are utilized by components to visualize data.</p> <p>The language emphasizes simplicity and ease of use, enabling developers to rapidly build applications without needing to manage low-level implementation details. At the same time, WebDSL is highly extensible, as it generates standard React and FastAPI code, making it easy to incorporate custom logic and advanced features when needed.</p> <p>A typical WebDSL webpage is composed of connections, data sources, entities, components, and screens. For example, a connection might link to a MongoDB database, with a specific query defined in the data source. An entity then describes the structure of the data, and a component, such as a bar chart, can visualize that data. Screens bring everything together by defining layouts and specifying which components appear.</p> <p>In summary, WebDSL is a powerful and flexible tool for rapidly developing full-stack applications, with a strong focus on data integration and visualization.</p>"},{"location":"#installation","title":"Installation","text":"<p>Download this repository and simply install using <code>pip</code> package manager.</p> <pre><code>git clone https://github.com/giannisgkountras/web-dsl\ncd web-dsl\npip install .\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Declarative Syntax: Define data sources, entities and components and their relationships in a clear and concise manner.</li> <li>Extensible: Easily add custom logic and components to fit your specific use case.</li> <li>Human-Readable: Applications are defined in a way that is easy to understand and maintain.</li> </ul> <p>Currently the DSL supports the following types of data sources:</p> <ul> <li>Message Broker: MQTT, AMQP, Redis</li> <li>REST API: REST API</li> <li>Database: MongoDB, MySQL</li> <li>Static: Static data</li> </ul> <p>And the following types of components:</p> <ul> <li>Text: Displays static or dynamic text content</li> <li>Image: Renders an image from a given source</li> <li>Bar Chart: Visualizes data using a bar chart</li> <li>Line Chart: Visualizes trends over time with a line chart</li> <li>Pie Chart: Displays proportional data in a pie chart format</li> <li>Table: Shows structured data in a tabular format, allowind CRUD operations</li> <li>Live Table: Real-time table that updates as new data arrives</li> <li>Form: Collects user input and submits it to a data source</li> <li>Notification: Displays alerts or status messages</li> <li>Gauge: Represents a single numeric value within a range</li> <li>JSON Viewer: Formats and displays JSON data for readability</li> <li>Alive Status: Indicates the active status of a broker topic</li> <li>Publisher: Sends messages to a broker topic</li> <li>Logs: Displays real-time log messages from broker topics</li> <li>Progress Bar: Visual indicator of progress</li> </ul>"},{"location":"components/","title":"Components","text":"<p>Components are used to define the visual representation of the data. They are defined using the following syntax:</p> <pre><code>Component ComponentName\n    type: &lt;ComponentType&gt;\n    entity: &lt;EntityName&gt;\nend\n</code></pre> <ul> <li>type: The type of the component.</li> <li>entity: The name of the entity to use. If not specified, the component should have static data.</li> </ul> <p>After declaring a component you can use it in any screen by referencing it by its name.</p> <pre><code>use ComponentName\n</code></pre> <p>You can also declare a component inline in a screen. This is useful when you want to use a simple component only in one screen and not in the whole application.</p>"},{"location":"components/#component-types","title":"Component Types","text":"<p>There are many component types available in the DSL. They all have a common way to access the data from the entity. The data is accessed using the accessors that have this syntax: <code>this.attribute_name[array_index]...</code> For example:</p> <ul> <li><code>this.temp[0]</code> will access the first element of the <code>temp</code> attribute of the entity.</li> <li><code>this.temp[0].value</code> will access the value of the first element of the <code>temp</code> attribute of the entity.</li> <li><code>this[0].data</code> will access the data of the first element of the entity.</li> </ul> <p>For components that support static data, the syntax is different. The data is provided by strings or lists. More details on each component type.</p> <p>Currently the DSL supports the following component types:</p>"},{"location":"components/#text","title":"Text","text":"<pre><code>Text\n    content: &lt;accessor&gt; | \"static text\"\n    size: 24\n    color: \"#fff\"\n    weight: \"600\"\n</code></pre> <ul> <li>content: The content of the text. It can be a string or an accessor.</li> <li>size: The font size of the text.</li> <li>color: The color of the text in hex string.</li> <li>weight: The font weight of the text.</li> </ul>"},{"location":"components/#image","title":"Image","text":"<pre><code>Image\n    source: &lt;accessor&gt; | \"static image\"\n    width: 100\n    height: 100\n</code></pre> <ul> <li>source: The source of the image. It can be a string or an accessor.</li> <li>width: The width of the image.</li> <li>height: The height of the image.</li> </ul>"},{"location":"components/#bar-chart","title":"Bar Chart","text":"<pre><code>BarChart\n    description: \"Description of the chart\"\n    xLabel: \"Label for x axis\"\n    yLabel: \"Label for y axis\"\n    xValue: &lt;accessor&gt; | \"static x value\"\n    yValues: &lt;accessor&gt;, &lt;accessor&gt;... | \"static y value\", \"static y value\"...\n    staticData: [ {...}, {...} ]\n</code></pre> <ul> <li>description: The description of the chart.</li> <li>xLabel: The label for the x axis.</li> <li>yLabel: The label for the y axis.</li> <li>xValue: The x value of the chart. It can be a string or an accessor.</li> <li>yValues: The y values of the chart. It can be strings or an accessors seperated by commas.</li> <li>staticData: The static data of the chart. It can be a list of dictionaries.</li> </ul>"},{"location":"components/#line-chart","title":"Line Chart","text":"<pre><code>LineChart\n    description: \"Description of the chart\"\n    xLabel: \"Label for x axis\"\n    yLabel: \"Label for y axis\"\n    xValue: &lt;accessor&gt; | \"static x value\"\n    yValues: &lt;accessor&gt;, &lt;accessor&gt;... | \"static y value\", \"static y value\"...\n    staticData: [ {...}, {...} ]\n</code></pre> <ul> <li>description: The description of the chart.</li> <li>xLabel: The label for the x axis.</li> <li>yLabel: The label for the y axis.</li> <li>xValue: The x value of the chart. It can be a string or an accessor.</li> <li>yValues: The y values of the chart. It can be strings or an accessors seperated by commas.</li> <li>staticData: The static data of the chart. It can be a list of dictionaries.</li> </ul>"},{"location":"components/#pie-chart","title":"Pie Chart","text":"<pre><code>PieChart\n    description: \"Chart title or description\"\n    dataName: &lt;accessor&gt; | \"static label key\"\n    value: &lt;accessor&gt; | \"static value key\"\n    staticData: [ {...}, {...} ]\n</code></pre> <ul> <li>description: The description of the chart.</li> <li>dataName: The key for each slice label, as accessor or static string.</li> <li>value: The key for each slice value, as accessor or static string.</li> <li>staticData: The static data of the chart. It can be a list of dictionaries.</li> </ul>"},{"location":"components/#table","title":"Table","text":"<pre><code>Table\n    primary_key: \"id\"\n    attributes: &lt;accessor&gt;, &lt;accessor&gt;, ...\n    description: \"Optional table description\"\n    table: \"collection_or_table_name\"\n    crud: true\n</code></pre> <ul> <li>primary_key: The primary key of the table.</li> <li>attributes: The data fields to display. It can be a list of accessors. Optional, if not specified, all attributes of the entity will be displayed.</li> <li>description: The description of the table.</li> <li>table: The name of the table or collection to use. Optional, for use with databases</li> <li>crud: If true, the table will support CRUD operations. This is supported only for databases.</li> </ul>"},{"location":"components/#live-table","title":"Live Table","text":"<pre><code>LiveTable\n    columns: &lt;accessor&gt;, &lt;accessor&gt;, ...\n</code></pre> <ul> <li>columns: The data fields to display. It can be a list of accessors. Optional, if not specified, all attributes of the entity will be displayed.</li> </ul>"},{"location":"components/#form","title":"Form","text":"<pre><code>Form\n    description: \"Form description\"\n    elements:\n        Label \"Your name\"\n        Input\n            type: text\n            placeholder: \"Enter name\"\n            datakey: \"username\"\n            required: true\n</code></pre> <ul> <li>description: The description of the form.</li> <li>elements: The elements of the form. It can be a list of elements. Each element can be a label or input.</li> <li>Label: The label of the element.</li> <li>Input: The input of the element. It can be a text, number, email, password or checkbox.</li> </ul>"},{"location":"components/#notification","title":"Notification","text":"<pre><code>Notification\n    type: success | error | warning | info\n    message: &lt;accessor&gt;\n</code></pre> <ul> <li>type: The type of the notification. It can be success, error, warning or info.</li> <li>message: The message of the notification. It can be an accessor.</li> </ul>"},{"location":"components/#gauge","title":"Gauge","text":"<pre><code>Gauge\n    value: &lt;accessor&gt; | 0.5\n    description: \"Battery level\"\n</code></pre> <ul> <li>value: The value of the gauge. It can be an accessor or a static value.</li> <li>description: The description of the gauge.</li> </ul>"},{"location":"components/#json-viewer","title":"JSON Viewer","text":"<pre><code>JsonViewer\n    attributes: &lt;accessor&gt;, &lt;accessor&gt;, ...\n</code></pre> <ul> <li>attributes: The keys to display. It can be a list of accessors. Optional, if not specified, all attributes of the entity will be displayed.</li> </ul>"},{"location":"components/#alive-status","title":"Alive Status","text":"<pre><code>Alive\n    timeout: 5000\n    description: \"Sensor alive status\"\n</code></pre> <ul> <li>timeout: The timeout in milliseconds. If the data source does not send data for this time, it will be considered dead.</li> <li>description: The description of the alive status.</li> </ul>"},{"location":"components/#publisher","title":"Publisher","text":"<pre><code>Publish\n    broker: &lt;broker_ref&gt;\n    endpoint: &lt;endpoint_ref&gt;\n    topic: \"topic/name\"\n    json: '{\"command\": \"start\"}'\n    description: \"Send start signal\"\n</code></pre> <ul> <li>broker: The name of the broker to use.</li> <li>endpoint: The name of the endpoint to use.     Either the broker or the endpoint is required.</li> <li>topic: The topic to publish to. If not specified, the publisher will have an input field to enter the topic.</li> <li>json: The JSON payload to send. If not specified, the publisher will have an input field to enter the payload.</li> <li>description: The description of the publisher.</li> </ul>"},{"location":"components/#logs","title":"Logs","text":"<pre><code>Logs\n    attributes: &lt;accessor&gt;, &lt;accessor&gt;, ...\n\n</code></pre> <ul> <li>attributes: The keys to display. It can be a list of accessors. Optional, if not specified, all attributes of the entity will be displayed.</li> </ul>"},{"location":"components/#progress-bar","title":"Progress Bar","text":"<pre><code>Progressbar\n    value: &lt;accessor&gt; | 0.4\n    max: &lt;accessor&gt; | 100\n    description: \"Loading progress\"\n    barColor: \"#00FF00\"\n    textColor: \"#000000\"\n    trackColor: \"#CCCCCC\"\n</code></pre> <ul> <li>value: The value of the progress bar. It can be an accessor or a static value.</li> <li>max: The maximum value of the progress bar. It can be an accessor or a static value.</li> <li>description: The description of the progress bar.</li> <li>barColor: The color of the progress bar. It can be a hex string.</li> <li>textColor: The color of the text. It can be a hex string.</li> <li>trackColor: The color of the track. It can be a hex string.</li> </ul>"},{"location":"conditions/","title":"Conditions","text":"<p>Conditions are very similar to conditions in imperative programming languages such as Python, Java, C++ or JavaScript. You can use Entity Attributes in a condition just like a variable by referencing it in the Condition using it's Fully-Qualified Name (FQN) in dot (.) notation. They are used to dynamically show or hide components based on the data received from the data sources.</p>"},{"location":"conditions/#condition-formatting","title":"Condition Formatting:","text":"<p>You can combine two conditions into a more complex one using logical operators but make sure to not forget the parenthesis.</p> <p>The supported logical operators are:</p> <ul> <li>AND: Logical AND</li> <li>OR: Logical OR</li> </ul>"},{"location":"conditions/#condition-examples","title":"Condition Examples","text":"<p>Given that we have an entity named <code>TempSensor1</code> with attributes <code>temp</code>, <code>humidity</code> and components named <code>MyComponent</code>, <code>MyOtherComponent</code> we can use the following conditions:</p> <pre><code>if TempSensor1.temp &gt; 10 and TempSensor1.humidity &lt; 20\n    use MyComponent, MyOtherComponent\n\nif 0 &gt; TempSensor1.temp &gt; 10 or TempSensor1.humidity &lt; 20\n    use MyComponent\nelse\n    use MyComponent, MyOtherComponent\n\nif TempSensor1.temp &gt; 10\n    use MyComponent\nelse if TempSensor1.temp &lt; 10\n    use MyOtherComponent\nelse\n    use MyComponent\n</code></pre> <p>The supported comparison operators are:</p> <ul> <li>&gt;: Greater than</li> <li>&lt;: Less than</li> <li>&gt;=: Greater than or equal to</li> <li>&lt;=: Less than or equal to</li> <li>==: Equal to</li> <li>!=: Not equal to</li> </ul>"},{"location":"connections/","title":"Connections","text":"<p>Connections are the way to connect to a data source. They are defined using the following syntax:</p>"},{"location":"connections/#for-message-brokers","title":"For message brokers","text":"<pre><code>Broker&lt;MQTT&gt; HomeMQTT\n    host: 'localhost'\n    port: 1883\n    auth:\n        username: ''\n        password: ''\nend\n\nBroker&lt;Redis&gt; LocalRedis\n    host: 'localhost'\n    port: 6379\n    db: 0\n    auth:\n        username: ''\n        password: ''\nend\n\nBroker&lt;AMQP&gt; MyAMQPBroker\n    host: 'localhost'\n    port: 5672\n    vhost: '/'\n    auth:\n        username: ''\n        password: ''\nend\n</code></pre> <ul> <li>host: Host IP address or hostname for the Broker</li> <li>port: Broker Port number</li> <li>auth: Authentication credentials. Unified for all communication brokers<ul> <li>username: Username used for authentication</li> <li>password: Password used for authentication</li> </ul> </li> <li>vhost (Optional): Vhost parameter. Only for AMQP brokers</li> <li>db (Optional): Database number parameter. Only for Redis brokers</li> </ul> <p>If at least one message broker is used, there must also be defined a websocket connection, that is used to connect the frontend with the backend. Only one websocket connection is needed for each application.</p> <pre><code>Websocket MyWebsocket\n    host: '0.0.0.0'\n    port: 8000\nend\n</code></pre> <ul> <li>host: Host IP address or hostname for the Websocket</li> <li>port: Websocket Port number</li> </ul>"},{"location":"connections/#for-databases","title":"For databases","text":"<pre><code>Database&lt;MongoDB&gt; HomeMongoDB\n    host: 'localhost'\n    port: 27017\n    database: 'mydb'\n    auth:\n        username: ''\n        password: ''\nend\n\nDatabase&lt;MySQL&gt; HomeMySQL\n    host: 'localhost'\n    port: 3306\n    database: 'mydb'\n    auth:\n        username: ''\n        password: ''\nend\n</code></pre> <ul> <li>host: Host IP address or hostname for the database</li> <li>port: Database Port number</li> <li>database: Database name</li> <li> <p>auth: Authentication credentials. Unified for all databases</p> <ul> <li>username: Username used for authentication</li> <li>password: Password used for authentication</li> </ul> </li> </ul>"},{"location":"connections/#for-rest-apis","title":"For REST APIs","text":"<pre><code>RestApi MyRestApi\n    host: 'http://localhost'\n    port: 8000\n    headers: {\"Authorization\": \"Bearer token\"}\nend\n</code></pre> <ul> <li>host: The url of the REST API</li> <li>port: The port of the REST API</li> <li>headers: Headers to be sent with the request. This is optional and can be used to send authentication tokens or other headers.</li> </ul> <p>If at least one REST API or database is used, there must also be defined an API connection, that is used to connect the frontend with the backend. Only one API connection is needed for each application.</p> <pre><code>API MyAPI\n    host: '0.0.0.0'\n    port: 8000\nend\n</code></pre> <ul> <li>host: Host IP address or hostname for the API</li> <li>port: API Port number</li> </ul> <p>Authentication between the frontend and the backend is automatically handled by the DSL. The frontend will automatically send the authentication token to the backend, and the backend will automatically validate the token. This is done for both the Websocket and the API connections. Also, all the information of the connections are stored in the backend.</p>"},{"location":"datasources/","title":"Data Sources","text":"<p>Data sources are the specific endpoints, queries or topics that are used to retrieve or send data. They are defined using the following syntax:</p>"},{"location":"datasources/#for-message-brokers","title":"For message brokers","text":"<pre><code>BrokerTopic TopicName\n    connection: &lt;BrokerName&gt;\n    topic: 'my/topic'\nend\n</code></pre> <ul> <li>connection: The name of the connection to the message broker</li> <li>topic: The topic to subscribe or publish to</li> </ul>"},{"location":"datasources/#for-databases","title":"For databases","text":"<pre><code>MySQLQuery MyQueryName\n    connection: &lt;DatabaseName&gt;\n    query: 'SELECT * FROM mytable'\nend\n\nMongoDBQuery MyQueryName\n    connection: &lt;DatabaseName&gt;\n    collection: 'mycollection'\n    filter: '{\"field\": \"value\"}'\nend\n</code></pre> <ul> <li>connection: The name of the connection to the database</li> <li>query: The SQL query to execute (for MySQL)</li> <li>collection: The name of the collection to query (for MongoDB)</li> <li>filter: The filter to apply to the query (optional for MongoDB)</li> </ul>"},{"location":"datasources/#for-rest-apis","title":"For REST APIs","text":"<pre><code>RestEndpoint EndpointName\n    connection: &lt;RestApiName&gt;\n    path: '/api/v1/resource'\n    method: 'POST'\n    body: {\"key\": \"value\"}\n    params: {\"param1\": \"value1\", \"param2\": \"value2\"}\n</code></pre> <ul> <li>connection: The name of the connection to the REST API</li> <li>path: The path of the endpoint</li> <li>method: The HTTP method to use (GET, POST, PUT, DELETE), if not specified, GET is used</li> <li>body: The body of the request (for POST and PUT), optional</li> <li>params: The query parameters to include in the request, optional</li> </ul>"},{"location":"entities/","title":"Entities","text":"<p>Entities are used to define data models and their relationships with data sources. They are defined using the following syntax:</p> <pre><code>Entity EntityName\n    description: 'Description of the entity'\n    source: &lt;DataSourceName&gt;\n    strict: true\n    interval: 5000\n    attributes:\n        - attribute_name: attribute_type\nend\n</code></pre> <ul> <li>description: A description of the entity,</li> <li>source: The name of the data source to use</li> <li>strict: When set to true, the entity only accepts data that matches its defined attributes exactly. Any undefined attributes will be rejected, and references to non-existent attributes will result in a validation error. When false, the entity can accept additional, undefined attributes without error.</li> <li>interval: The interval in milliseconds for the entity to reload data from the data source. This is optional and can be used to set a custom interval for the entity in case of rest apis and databases.</li> <li>attributes: A list of attributes for the entity. Each attribute has a name and a type.</li> <li>attribute_name: The name of the attribute</li> <li>attribute_type: The type of the attribute. The supported types are int, float, string, bool, list and dict.</li> </ul>"},{"location":"entities/#entity-overloading","title":"Entity Overloading","text":"<p>Entity overloading is a feature that allows you to a new entity that will replace an existing entity everywhere in the model. This is useful when you want to change the behavior of an entity without having to change all the references to it.</p> <pre><code>Entity NewEntityName overloads OldEntityName\n    description: 'Description of the entity'\n    source: &lt;DataSourceName&gt;\n    strict: true\n    interval: 5000\n    attributes:\n        - attribute_name: attribute_type\nend\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Several examples of usage can be found under the examples directory of this repository.</p>"},{"location":"features/","title":"Features","text":"<ul> <li>Declarative Syntax: Define data sources, entities and components and their relationships in a clear and concise manner.</li> <li>Extensible: Easily add custom logic and components to fit your specific use case.</li> <li>Human-Readable: Applications are defined in a way that is easy to understand and maintain.</li> </ul> <p>Currently the DSL supports the following types of data sources:</p> <ul> <li>Message Broker: MQTT, AMQP, Redis</li> <li>REST API: REST API</li> <li>Database: MongoDB, MySQL</li> <li>Static: Static data</li> </ul> <p>And the following types of components:</p> <ul> <li>Text: Displays static or dynamic text content</li> <li>Image: Renders an image from a given source</li> <li>Bar Chart: Visualizes data using a bar chart</li> <li>Line Chart: Visualizes trends over time with a line chart</li> <li>Pie Chart: Displays proportional data in a pie chart format</li> <li>Table: Shows structured data in a tabular format, allowind CRUD operations</li> <li>Live Table: Real-time table that updates as new data arrives</li> <li>Form: Collects user input and submits it to a data source</li> <li>Notification: Displays alerts or status messages</li> <li>Gauge: Represents a single numeric value within a range</li> <li>JSON Viewer: Formats and displays JSON data for readability</li> <li>Alive Status: Indicates the active status of a broker topic</li> <li>Publisher: Sends messages to a broker topic</li> <li>Logs: Displays real-time log messages from broker topics</li> <li>Progress Bar: Visual indicator of progress</li> </ul>"},{"location":"generation/","title":"Generation","text":"<p>Code generation is perfomed using either the CLI or the REST API of the DSL.</p> <p>In the case of the CLI, <code>generate</code> is a subcommand of <code>webdsl</code>.</p> <p>To generate the source code of a WebDSL model, execute:</p> <pre><code>webdsl generate &lt;webdsl_file&gt; &lt;output_dir&gt;\n</code></pre> <p>The generated code will be placed in the specified output directory. If no output dir is provided, the code will be generated in the current directory.</p>"},{"location":"goaldsl/","title":"GoalDSL Transformation","text":"<p>WebDSL also supports transforming GoalDSL into WebDSL models. This is currently only supported on the REST API of WebDSL and not on the CLI.</p>"},{"location":"import/","title":"Imports","text":"<p>The language supports multi-file models via model imports. A nested model import layer is implemented, enabling pythonic imports of models defined in other files.</p> <pre><code>// webpage.wdsl\n\nimport \"screens.wdsl\"\n\nWebpage MyWebpage\n    author: \"\"\n    version: \"1.0\"\n    description: \"\"\n    navbar: true\n\n    API backendAPI\n        host: \"0.0.0.0\"\n        port: 8321\n    end\n\n    Websocket backendWebsocket\n        host: \"localhost\"\n        port: 8080\n    end\n</code></pre> <pre><code>// screens.wdsl\nimport \"components.wdsl\"\n\nScreen Home\n    title: \"Home\"\n    url: \"/\"\n\n    use InfoNotifications\n\n    row\n        col\n            use ProductsTable\n        endcol\n        col\n            use WarehousesTable\n        endcol\n    endrow\nend\n</code></pre> <p>The model can be seperated into as many files as needed.</p>"},{"location":"loops/","title":"Loops","text":"<p>Loops are used to iterate over a list of elements coming from the live data source. They are used to dynamically show or hide components based on the data received from the data sources. Loops currently support only the Text, Image and Gauge components.</p>"},{"location":"loops/#loop-formatting","title":"Loop Formatting:","text":"<p>You can use the following syntax to define a loop:</p> <pre><code>for item in &lt;entity_name&gt;.&lt;attribute_name&gt;\n    use Text with item.value\n    orientation: column\n</code></pre> <ul> <li>orientation: The orientation of the loop. It can be column or row.</li> <li>with: The data accessor to use with the item. It needs to start with <code>item</code> and follows the accessor logic. If not specified, the component should have static data.</li> </ul> <p>There can also be if statements inside the loop to show only a part of the data based on a condition. This condition is simpler than the one used in the conditions section. You can use the following syntax to define a condition inside a loop:</p> <pre><code>for item in CarData.metrics\n    use Gauge with item.value if item.value &gt; 30\n    else use Text content:\"Low Value\"\n    orientation: column\n</code></pre>"},{"location":"openapi/","title":"OpenAPI Transformation","text":"<p>WebDSL also supports transforming OpenAPI specifications into WebDSL models using the openapi subcommand of the webdsl CLI tool. This transformation automatically generates the necessary components, entities, and data sources based on the provided OpenAPI specification. The resulting model can then be used to generate the full application source code.</p> <p>By default, the transformation extracts the API connection details and creates a separate data source for each endpoint defined in the OpenAPI spec.</p>"},{"location":"openapi/#augmenting-openapi-with-webdsl","title":"Augmenting OpenAPI with WebDSL","text":"<p>WebDSL allows you to enhance the OpenAPI specification by using a custom header on specific endpoints. You can add the following annotation to generate UI components:</p> <pre><code>x-webdsl:\n    - this.id -&gt; Gauge @ 1,1\n    - this[0].title -&gt; Text @ 1,2\n</code></pre> <p>In this example:</p> <p>A Gauge component will be generated from the id field of the response.</p> <p>A Text component will be generated from the title field of the first item in the response array.</p> <p>The @ 1,1 and @ 1,2 specify the row and column positions of the components (1-indexed).</p> <p>To transform an OpenAPI specification into a WebDSL model, execute:</p> <pre><code>webdsl openapi &lt;openapi_file&gt; &lt;output_dir&gt;\n</code></pre> <p>If the OpenAPI file is valid, the generated WebDSL model will be placed in the specified output directory. If no output dir is provided, the code will be generated in the current directory.</p>"},{"location":"screens/","title":"Screens","text":"<p>Screens are used to define the layout of the application. They are defined using the following syntax:</p> <pre><code>Screen ScreenName\n    description: \"Description of the screen\"\n    title: \"Title of the screen\"\n    url: \"/home\"\n\n\nend\n</code></pre> <ul> <li>description: The description of the screen.</li> <li>title: The title of the screen also used in the navbar.</li> <li>url: The url of the screen. This is used to navigate to the screen.</li> </ul> <p>Each screen can contain rows and columns to define the layout, links to other screens or external urls, components, conditions and loops. The syntax for defining a row is:</p> <pre><code>row\nendrow\n\n</code></pre> <p>The syntax for defining a column is:</p> <pre><code>col\nendcol\n</code></pre> <p>The syntax for defining a link is:</p> <pre><code>link\n    url: \"/home\"\n    text: \"Home\"\nend\n</code></pre> <p>The syntax for using a component is:</p> <pre><code>use ComponentName\n</code></pre> <p>or you can define it inline.</p> <p>A complete example of a screen is:</p> <pre><code>Screen Home\n    description: \"Home screen\"\n    title: \"Home\"\n    url: \"/home\"\n    row\n        col\n            use MyComponent1\n        endcol\n        col\n            Component Title\n                type: Text content: \"Hello World\"\n            end\n        endcol\n    endrow\nend\n</code></pre>"},{"location":"validation/","title":"Validation","text":"<p>Validation is perfomed using either the CLI or the REST API of the DSL.</p> <p>In the case of the CLI, <code>validate</code> is a subcommand of <code>webdsl</code>.</p> <p>To validate a WebDSL model file, execute:</p> <pre><code>webdsl validate &lt;webdsl_file&gt;\n</code></pre> <p>If the model passes the validation rules (grammar) you should see something like:</p> <pre><code>\u2714 Model is valid.\n</code></pre>"},{"location":"webpage/","title":"Webpage","text":"<p>The webpage is the main entry point of the application. It is defined using the following syntax:</p> <pre><code>Webpage WebPageName\n    author: \"Author Name\"\n    version: \"1.0.0\"\n    description: \"Description of the webpage\"\n    navbar: &lt;ScreenName&gt;, &lt;ScreenName&gt;...\n</code></pre> <ul> <li>author: The author of the webpage</li> <li>version: The version of the webpage</li> <li>description: A description of the webpage</li> <li>navbar: A list of screens to include in the navbar. The screens are separated by commas. The navbar is optional will not be shown if no screens are given.</li> </ul>"}]}